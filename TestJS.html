<html>
<head>
<script type="text/javascript" src="js-test.js" ></script>
</head>
<body>
<h3>Various tests below...</h3>
<p></p>
<canvas id="myCanvas" width="1250" height="800" style="border:1px solid #d3d3d3;">
Your browser does not support the HTML5 canvas tag.</canvas>
<p>&nbsp;</p>
Select the # of points to generate <select id="sel1"></select> <br>
<input type="button" value="Generate" onclick="javascript:loadPoints()" /> &nbsp;
<input type="button" value="Clear" id="clear" /> &nbsp;
<input type="button" id="iterate" value="Run 50 iterations"/> &nbsp;
<input type="button" id="stop" value="Stop iterations" />&nbsp;
<script>

var c = document.getElementById("myCanvas");
var ctx = c.getContext("2d");

var width=c.getAttribute("width");
var height=c.getAttribute("height");
var minDimension = Math.min(width, height);

document.getElementById('clear').addEventListener('click', function() {
        ctx.clearRect(0, 0, c.width, c.height);
      }, false);
	  
document.getElementById('iterate').addEventListener('click', function(){
	   runIter(50);
}, false);	  

document.getElementById('stop').addEventListener('click', function(){
	clearInterval(PKNS.timer);
	}, false);
	  
// populate select box
var select=document.getElementById("sel1");
for(var i=10;i<=500;i++) {
     var option = document.createElement("option");
	 option.setAttribute("value", i);
	 if(i==50) option.setAttribute("selected", true);
	 option.innerHTML = i;
	 select.appendChild(option);
}	  

function randomColor() {
	var r1=Math.floor(Math.random()*255);
	var g1=Math.floor(Math.random()*255);
	var b1=Math.floor(Math.random()*255);
	return "rgb(" + r1 + "," + g1 + "," + b1 + ")";
}	  

function drawEdge(ctx, from, to, width, r) {
	ctx.beginPath();
	ctx.lineWidth = width;
	ctx.lineCap = "butt";
	ctx.moveTo(from.X, from.Y);
	ctx.strokeStyle=randomColor();
	ctx.lineTo(to.X, to.Y);	
	//ctx.quadraticCurveTo(Math.max(0,(to.X-from.X)*0.55 ), Math.max(0,(to.Y-from.Y)*0.55),to.X, to.Y);
	/*
	var gradient=ctx.createLinearGradient(0,0,1205,0);
	gradient.addColorStop("0",randomColor());
	gradient.addColorStop("0.5",randomColor());
	gradient.addColorStop("1.0",randomColor());	
	ctx.fillStyle=gradient;
	ctx.fill();
	*/	
	ctx.stroke();	
    drawArrowHead(ctx, from, to, r/2);
}

function drawArrowHead(context, from, to, headlen){
    //var headlen = 15;   // length of head in pixels
	//context.beginPath();
    var angle = Math.atan2(to.Y-from.Y,to.X-from.X);
    context.moveTo(from.X, from.Y);
    context.lineTo(to.X, to.Y);
    context.stroke();
    context.lineTo(to.X-headlen*Math.cos(angle-Math.PI/6),to.Y-headlen*Math.sin(angle-Math.PI/6));
    context.stroke();
    context.moveTo(to.X, to.Y);
    context.lineTo(to.X-headlen*Math.cos(angle+Math.PI/6),to.Y-headlen*Math.sin(angle+Math.PI/6));
    context.stroke();
}

function paintCircle(ctx, x,y,r) {
	ctx.beginPath();
	ctx.arc(x, y, r, 0, 2 * Math.PI);
	ctx.stroke();
	ctx.fillStyle=randomColor();
	ctx.fill();
}

function loadPoints() {
	
	var numPoints = select.value;
	
	var radius = Math.ceil(Math.sqrt(minDimension/numPoints));
	
	var x_sections = Math.ceil(Math.sqrt(numPoints));
    var y_sections = Math.floor(numPoints/x_sections);
	
	var x_width=width/x_sections;
	var y_width=height/y_sections;
	
	var nodes =0;	
    var padding = 5;	
		
	outerloop:
	for(var x=1;x<=x_sections; x++) {
	   for(y=1;y<=y_sections; y++) {			
			
			var x_coord = x_width*(x-Math.random()*0.85);
			var y_coord = y_width*(y-Math.random()*0.85);
			var r=radius*2*Math.max(0.5,Math.random());					
			
			while(x_coord+r > width-padding) x_coord-=2*Math.random();
			while(y_coord+r > height-padding) y_coord-=2*Math.random();
			while(x_coord-r < padding) x_coord+=2*Math.random();
			while(y_coord-r < padding) y_coord+=2*Math.random();
			
			paintCircle(ctx, x_coord, y_coord, r);			
			
			if(++nodes == numPoints) break outerloop;
		}
	}
	
	while(nodes++ < numPoints) {
		var x_coord = Math.random()*width;
		var y_coord = Math.random()*height;
		
		while(x_coord+r > width-padding) x_coord-=2*Math.random();
		while(y_coord+r > height-padding) y_coord-=2*Math.random();
		while(x_coord-r < padding) x_coord+=2*Math.random();
		while(y_coord-r < padding) y_coord+=2*Math.random();
		
		var r=radius*2; //*Math.max(0.5,Math.random());
		
		paintCircle(ctx, x_coord, y_coord, r);		
	}
}

function runIter(n) {
    var runs=0;
	PKNS.timer = setInterval(function(){
		loadPoints();
		if(++runs == n) clearInterval(PKNS.timer);
	}, 800);	
}




function drawNodes(arr, graph) {
	
	var numPoints = arr.length;
		
	var r = Math.ceil(2*Math.sqrt(minDimension/numPoints));
	
	var x_sections = Math.ceil(Math.sqrt(numPoints));
    var y_sections = Math.floor(numPoints/x_sections);
	
	var width=c.getAttribute("width");
	var height=c.getAttribute("height");
	
	var x_width=width/x_sections;
	var y_width=height/y_sections;
	
	var nodesDrawn =0;
	
	var x=1;
	var y=1;
	var padding = 5;
	var lineWidth=1.5;

	arr.forEach(function(val, index, arrayObj) {
		// skip first iteration, as we'll always look back to prev element
		if(index==0) return;
		 
		prevElement = arrayObj[index-1];
		currElement = val;
		 
		var iter= index==1? 0 : 1;  // we only need to set prev Element once, all other times it's already set		 
		 
		while(iter++ < 2) {
			if(y <= y_sections) { y++; } 
			else {x++; y=1;}
			var x_coord = x_width/1.5*(x-Math.random()*0.65);
			var y_coord = y_width/1.5*(y-Math.random()*0.75);
				
			while(x_coord + r > width-padding) x_coord-=2*Math.random();
			while(y_coord + r > height-padding) y_coord-=2*Math.random();
			while(x_coord - r < padding) x_coord+=2*Math.random();
			while(y_coord - r < padding) y_coord+=2*Math.random();		
			
			paintCircle(ctx, x_coord, y_coord, r);			
				
			if(iter==1) {
				graph.setNodeMetaInfo(prevElement, {X:x_coord, Y:y_coord});
			} else {
				graph.setNodeMetaInfo(currElement, {X:x_coord, Y:y_coord});
			}
		}

		drawEdge(ctx, graph.getNodeMetaInfo(prevElement), graph.getNodeMetaInfo(currElement), lineWidth, r);
		drawText(ctx, graph.getNodeMetaInfo(prevElement).X+r+2, graph.getNodeMetaInfo(prevElement).Y-r-2, prevElement);
		drawText(ctx, graph.getNodeMetaInfo(currElement).X+r+2, graph.getNodeMetaInfo(currElement).Y-r-2, currElement);
			
	});
}

function drawText(ctx, x, y, text) {
	ctx.font="14px Georgia";
	ctx.fillStyle="black";
	ctx.fillText(text, x, y);
}

// Usage:

g2=new PKNS.Graph()
g2.addEdges([ [0,1],[0,2],[0,3],[3,4],[2,1],[4,2],[4,5],[5,1],[1,6],[6,7],[6,8],[7,9],[9,10],[8,10] ]);
var nodeArray = g2.topologicalSort();
// draws the topological sort path
drawNodes(nodeArray, g2);
// draws the rest of the edges

drawEdge(ctx, g2.getNodeMetaInfo(0), g2.getNodeMetaInfo(1), 1.5, 15);
drawEdge(ctx, g2.getNodeMetaInfo(0), g2.getNodeMetaInfo(2), 1.5, 15);
drawEdge(ctx, g2.getNodeMetaInfo(0), g2.getNodeMetaInfo(3), 1.5, 15);
drawEdge(ctx, g2.getNodeMetaInfo(2), g2.getNodeMetaInfo(1), 1.5, 15);
drawEdge(ctx, g2.getNodeMetaInfo(8), g2.getNodeMetaInfo(10), 1.5, 15);
drawEdge(ctx, g2.getNodeMetaInfo(6), g2.getNodeMetaInfo(8), 1.5, 15);
drawEdge(ctx, g2.getNodeMetaInfo(2), g2.getNodeMetaInfo(1), 1.5, 15);
drawEdge(ctx, g2.getNodeMetaInfo(4), g2.getNodeMetaInfo(5), 1.5, 15);


//g3= new PKNS.Graph();
//a1=new Array();
//for(var x=0;x<100;x++) { var add1=Math.random()>0.5? 1 : 2; a1.push([x,x+add1]); if(x>10 && Math.random()>0.5) {a1.push([x-add1*2,x]);} }
//g3.addEdges(a1);
//drawNodes(g3.topologicalSort(), g3);

</script>

</body>
</html>